# React 性能优化经验

## 状态管理和副作用

### 1. 避免不必要的 useEffect
- 不要使用 `useEffect` 来同步可以直接通过 props 传递的状态
- 只在真正需要处理副作用时使用（如 API 调用、订阅事件等）
- 当需要在多个组件间共享状态时，优先考虑状态管理工具（如 Redux）而不是靠 `useEffect` 同步

### 2. 状态设计原则
- 遵循单向数据流，让数据流向清晰可预测
- 避免重复或冗余的状态，减少状态同步的需求
- 将状态尽可能放在最近的共同父组件中

### 3. 实际案例
Navigation 组件中的路径同步优化：
```jsx
// 优化前：使用 useEffect 同步状态
const [searchValue, setSearchValue] = useState(currentPath);
useEffect(() => {
  setSearchValue(currentPath);
}, [currentPath]);

// 优化后：直接使用 props
<AutoComplete value={currentPath} />
```

### 4. 终端输入状态管理经验
在处理终端输入状态时，我们遇到了一个典型的问题：使用 React 的 `useState` 无法在事件处理器中及时获取到最新的状态值。

问题场景：
```typescript
// 错误的方式：使用 useState
const [pendingCommand, setPendingCommand] = useState('');

// 在事件处理器中，可能无法获取到最新的值
terminal.onKey(({ key, domEvent }) => {
  if (domEvent.key === 'Enter') {
    console.log('Current command:', pendingCommand); // 可能是旧值
  }
});
```

解决方案：
```typescript
// 正确的方式：使用 useRef
const pendingCommandRef = useRef('');
const updatePendingCommand = useCallback((newCommand: string) => {
  pendingCommandRef.current = newCommand;
}, []);

// 在事件处理器中，总是能获取到最新的值
terminal.onKey(({ key, domEvent }) => {
  if (domEvent.key === 'Enter') {
    console.log('Current command:', pendingCommandRef.current); // 总是最新值
  }
});
```

优化效果：
- 避免了状态更新的异步性导致的问题
- 确保在事件处理器中能获取到最新的状态
- 减少了不必要的组件重渲染
- 提高了代码的可预测性和可靠性

关键经验：
1. 当需要在事件处理器中访问状态时，优先考虑使用 `useRef`
2. 对于不需要触发重渲染的状态更新，使用 `useRef` 比 `useState` 更合适
3. 使用 `useCallback` 包装更新函数，确保函数引用的稳定性
4. 在处理用户输入等实时性要求高的场景，应该特别注意状态的同步性

## 最佳实践总结
1. 性能优化应该是开发初期就要考虑的事情，而不是等到出现问题再优化
2. 在选择实现方案时，应该优先考虑性能影响，选择最简单且高效的方案
3. 代码简洁通常意味着更好的性能和可维护性
4. 在处理状态时，要根据使用场景选择合适的状态管理方式（useState vs useRef）
