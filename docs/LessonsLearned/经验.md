# React 性能优化经验

## 状态管理和副作用

### 1. 避免不必要的 useEffect
- 不要使用 `useEffect` 来同步可以直接通过 props 传递的状态
- 只在真正需要处理副作用时使用（如 API 调用、订阅事件等）
- 当需要在多个组件间共享状态时，优先考虑状态管理工具（如 Redux）而不是靠 `useEffect` 同步

### 2. 状态设计原则
- 遵循单向数据流，让数据流向清晰可预测
- 避免重复或冗余的状态，减少状态同步的需求
- 将状态尽可能放在最近的共同父组件中

### 3. 实际案例
Navigation 组件中的路径同步优化：
```jsx
// 优化前：使用 useEffect 同步状态
const [searchValue, setSearchValue] = useState(currentPath);
useEffect(() => {
  setSearchValue(currentPath);
}, [currentPath]);

// 优化后：直接使用 props
<AutoComplete value={currentPath} />
```

### 4. 终端输入状态管理经验
在处理终端输入状态时，我们遇到了一个典型的问题：使用 React 的 `useState` 无法在事件处理器中及时获取到最新的状态值。

问题场景：
```typescript
// 错误的方式：使用 useState
const [pendingCommand, setPendingCommand] = useState('');

// 在事件处理器中，可能无法获取到最新的值
terminal.onKey(({ key, domEvent }) => {
  if (domEvent.key === 'Enter') {
    console.log('Current command:', pendingCommand); // 可能是旧值
  }
});
```

解决方案：
```typescript
// 正确的方式：使用 useRef
const pendingCommandRef = useRef('');
const updatePendingCommand = useCallback((newCommand: string) => {
  pendingCommandRef.current = newCommand;
}, []);

// 在事件处理器中，总是能获取到最新的值
terminal.onKey(({ key, domEvent }) => {
  if (domEvent.key === 'Enter') {
    console.log('Current command:', pendingCommandRef.current); // 总是最新值
  }
});
```

优化效果：
- 避免了状态更新的异步性导致的问题
- 确保在事件处理器中能获取到最新的状态
- 减少了不必要的组件重渲染
- 提高了代码的可预测性和可靠性

关键经验：
1. 当需要在事件处理器中访问状态时，优先考虑使用 `useRef`
2. 对于不需要触发重渲染的状态更新，使用 `useRef` 比 `useState` 更合适
3. 使用 `useCallback` 包装更新函数，确保函数引用的稳定性
4. 在处理用户输入等实时性要求高的场景，应该特别注意状态的同步性

## SSH 连接管理经验

### 1. 连接复用的重要性
在处理 SSH 连接时，我们遇到了一个典型问题：每次执行命令都创建新连接导致上下文丢失。

问题场景：
```typescript
// 错误的方式：每次都创建新连接
async function executeCommand(command: string) {
  const client = new Client();
  await client.connect(config);
  const result = await client.exec(command);
  client.end();
  return result;
}
```

解决方案：
```typescript
// 正确的方式：使用连接池管理和复用连接
class SSHManager {
  private connections = new Map<string, SSHConnection>();
  
  async getConnection(sessionId: string) {
    let conn = this.connections.get(sessionId);
    if (conn && await this.testConnection(conn)) {
      return conn; // 复用现有连接
    }
    // 创建新连接...
  }
  
  async executeCommand(sessionId: string, command: string) {
    const conn = await this.getConnection(sessionId);
    return conn.exec(command);
  }
}
```

优化效果：
- 保持了 SSH 会话的上下文（如当前工作目录）
- 减少了连接建立的开销
- 提高了命令执行的可靠性
- 避免了频繁的连接创建和销毁

关键经验：
1. 使用连接池管理 SSH 连接，而不是每次都创建新连接
2. 实现连接健康检查机制，及时检测和清理失效连接
3. 添加连接超时和心跳机制，确保连接的稳定性
4. 在连接断开时自动清理相关资源
5. 使用单例模式管理连接池，避免重复创建

### 2. 实现要点
- 添加连接超时处理（如10秒）
- 实现定期心跳检测（如每10秒一次）
- 设置重试次数限制（如最多重试3次）
- 在连接断开时自动清理缓存
- 确保命令执行的上下文一致性

### 3. 连接生命周期管理
在处理多标签页终端时，我们发现了一个关于 SSH 连接生命周期管理的重要优化点。

问题场景：
```typescript
// 次优的方式：使用定时器管理连接生命周期
class SSHManager {
  private cleanupTimer: NodeJS.Timeout;
  
  constructor() {
    // 定期检查并清理空闲连接
    this.cleanupTimer = setInterval(() => {
      this.cleanupIdleConnections();
    }, 5 * 60 * 1000);
  }
  
  private cleanupIdleConnections() {
    // 检查每个连接的最后使用时间，关闭空闲连接
    // 可能导致活跃标签页的连接被意外关闭
  }
}
```

优化方案：
```typescript
// 优化后：将连接生命周期与标签页生命周期绑定
class SSHManager {
  // 在标签页创建时创建连接
  async createConnectionForTab(tabId: string, sessionInfo: SessionInfo) {
    const connection = await this.createConnection(sessionInfo);
    this.connections.set(tabId, connection);
  }
  
  // 在标签页关闭时销毁连接
  closeConnectionForTab(tabId: string) {
    const connection = this.connections.get(tabId);
    if (connection) {
      connection.end();
      this.connections.delete(tabId);
    }
  }
}
```

优化效果：
- 提高了补全响应速度（无需等待连接创建）
- 减少了连接管理的复杂性
- 避免了连接被意外关闭的问题
- 资源管理更加精确和可控

关键经验：
1. 将 SSH 连接的生命周期与业务逻辑（如标签页）绑定，而不是依赖定时清理
2. 在用户操作（如关闭标签页）时主动清理资源，而不是被动等待
3. 避免使用基于时间的资源回收策略，除非真的必要
4. 保持连接生命周期的可预测性，有助于提高系统稳定性

## 最佳实践总结
1. 性能优化应该是开发初期就要考虑的事情，而不是等到出现问题再优化
2. 在选择实现方案时，应该优先考虑性能影响，选择最简单且高效的方案
3. 代码简洁通常意味着更好的性能和可维护性
4. 在处理状态时，要根据使用场景选择合适的状态管理方式（useState vs useRef）
